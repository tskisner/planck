import logging as l
import numpy as np

import physcon

from testenv.lfidipole import SatelliteVelocity

import quaternionarray as qarray
from pointingtools import mat3_np
import private

from tabulate_corrections_calc import TabulatedAttitudeCorrections

def deaberration(vec, obt, coord):
    satvel = SatelliteVelocity(coord).orbital_v(obt)
    return np.cross(vec, np.cross(vec, satvel/physcon.c))

def simple_deaberration(vec, obt, coord):
    l.critical('Applying SIMPLE deaberration correction')
    satvel = SatelliteVelocity(coord, interp='linear').orbital_v(obt)
    return -1 * satvel/physcon.c

def get_wobble_psi2_maris(obt):
    TAC=TabulatedAttitudeCorrections(private.WOBBLE['sun_file'],private.WOBBLE['planck_file'])
    return np.radians(
                TAC.TabulatePsi2(obt*2**16) /60.
            )

def get_wobble_psi2(obt, filename=None):
    """Reads psi2 wobble angle from file generated by Michele's standalone code"""
    if filename is None:
        filename = private.WOBBLE['psi2_file']

    w = np.loadtxt(filename, delimiter=',', skiprows=1)

    return np.radians(
                np.interp(obt, w[:,1]/2**16, w[:,2])/60.
            )

def wobble(obt, wobble_psi2_model=get_wobble_psi2_maris):
    """Gets array of OBT and returns an array of quaternions"""

    R_psi1 = qarray.inv(qarray.rotation([0,0,1], private.WOBBLE['psi1_ref']))
    R_psi2 = qarray.inv(qarray.rotation([0,1,0], private.WOBBLE['psi2_ref']))

    psi2 = wobble_psi2_model(obt)
    R_psi2T = qarray.rotation([0,1,0], psi2)

    wobble_rotation = qarray.mult(qarray.inv(R_psi1),
                            qarray.mult(R_psi2T , 
                                qarray.mult(R_psi2 , R_psi1)
                            )
                        )

    return wobble_rotation

def wobble_rotmat(obt, wobble_psi2_model=get_wobble_psi2_maris):
    """Gets array of OBT and returns an array of quaternions"""
    from cgkit.cgtypes import mat3, vec3

    R_psi1 = mat3.rotation(private.WOBBLE['psi1_ref'], vec3(0,0,1)).transpose()
    R_psi2 = mat3.rotation(private.WOBBLE['psi2_ref'], vec3(0,1,0)).transpose()
    psi2 = wobble_psi2_model(obt[:1])
    R_psi2T = mat3.rotation(psi2, vec3(0,1,0))
    wobble_rotation = R_psi1.transpose() * (R_psi2T * (R_psi2 * R_psi1))
                                                                                                                                                               
    return mat3_np(wobble_rotation)
